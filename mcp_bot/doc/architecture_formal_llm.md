# Формальний опис архітектури GZDoom

## 1. Загальна структура

GZDoom — це модульний рушій для ігор на основі Doom, написаний на C++. Архітектура побудована за принципом розділення відповідальностей між підсистемами. Кожна підсистема має чітко визначену роль, що забезпечує масштабованість, підтримку модифікацій та інтеграцію нових технологій.

### Основні підсистеми:
- **Ядро рушія (`src/`)**: 
  - Відповідає за ініціалізацію програми, головний цикл, менеджмент ресурсів, конфігурацію, обробку помилок, логування, взаємодію з ОС.
  - Містить точки входу, основні цикли, менеджери ресурсів, системи подій, інтерфейси для розширення.
- **Ігрова логіка**: 
  - Реалізує правила гри, управління станом, гравцями, рівнями, акторами, AI, фізику, сценарії.
  - Включає модулі для обробки подій, апдейту стану світу, взаємодії між об'єктами.
- **Рендеринг**: 
  - Відповідає за побудову кадру, використовуючи OpenGL/Vulkan, BSP-дерева, освітлення, UI.
  - Забезпечує абстракцію над графічними API, підтримку різних платформ, ефекти, HUD.
- **Зовнішні бібліотеки (`libraries/`)**: 
  - Підключаються для компресії, аудіо, графіки, віджетів, DiscordRPC, Vulkan, тощо.
  - Інкапсулюють сторонній функціонал, що не є частиною ядра.
- **Ресурси**: 
  - WAD/PK3, саундфонти, банки MIDI, текстури, карти, які використовуються для побудови ігрового світу.
  - Підсистема ресурсів відповідає за завантаження, кешування, пошук і валідацію даних.
- **Інструменти (`tools/`)**: 
  - Утиліти для розробки, збірки, обробки ресурсів, тестування, автоматизації.
- **Документація (`docs/`, `mcp_bot/doc/`)**: 
  - Опис архітектури, інтеграцій, специфікації, інструкції для розробників і моддерів.

## 2. Життєвий цикл програми

### 2.1. Точки входу
- **main**: 
  - Для Linux: `src/common/platform/posix/sdl/i_main.cpp`.
  - Для Windows: `src/common/platform/win32/i_main.cpp`.
  - Відповідає за старт програми, обробку аргументів командного рядка, ініціалізацію платформи, виклик `D_DoomMain`.
- **D_DoomMain (`src/d_main.cpp`)**: 
  - Головна точка запуску рушія. Виконує ініціалізацію ресурсів, налаштувань, завантаження WAD/PK3, парсинг параметрів, підготовку ігрового середовища.
  - Відповідає за обробку помилок, логування, підготовку до запуску ігрового циклу.
- **D_InitGame (`src/d_main.cpp`)**: 
  - Ініціалізує ігровий стан: створює гравців, завантажує рівень, налаштовує класи, AI, інвентар, конфігурації.
  - Встановлює початкові значення для всіх ігрових структур.
- **D_DoomLoop (`src/d_main.cpp`)**: 
  - Нескінченний цикл гри. В кожній ітерації викликає:
    - `G_Ticker()` (`src/g_game.cpp`): оновлення логіки, фізики, AI, стану світу.
    - `G_Responder()` (`src/g_game.cpp`): обробка подій (input, мережа, скрипти).
    - `D_Display()` (`src/d_main.cpp`): рендеринг кадру, оновлення UI.
  - Забезпечує синхронізацію між підсистемами, контроль FPS, обробку винятків.

### 2.2. Основні структури даних
- **player_t (`src/playsim/d_player.h`)**: 
  - Описує стан гравця: координати, швидкість, кут огляду, здоров'я, інвентар, активна зброя, камера, стани (наприклад, живий/мертвий).
  - Містить посилання на об'єкт-актор (`AActor`), що представляє гравця у світі.
- **AActor (`src/playsim/actor.h`)**: 
  - Базовий клас для всіх об'єктів світу: гравці, монстри, предмети, декорації.
  - Містить позицію, напрямок, стан, властивості, методи взаємодії, посилання на рівень.
- **FLevelLocals (`src/g_levellocals.h`)**: 
  - Описує стан поточного рівня: масив гравців, ітератор по акторам, властивості карти, тригери, таймери, глобальні змінні.
  - Забезпечує доступ до всіх об'єктів і подій на рівні.

## 3. Потенційна інтеграція LLM

### 3.1. Точки збору інформації
- **Після G_Ticker, до D_Display**: 
  - На цьому етапі всі стани світу оновлені, можна зібрати інформацію для LLM (позиція, стан гравця, видимі актори, події).
  - Дозволяє формувати повний знімок ігрового стану для аналізу або генерації дій LLM.
- **player_t / AActor**: 
  - Прямий доступ до полів для формування структур/JSON для LLM. Можна отримати координати, стан, інвентар, видимість, взаємодії.

### 3.2. Потік інтеграції
1. Оновлення стану світу (`G_Ticker`): всі об'єкти, гравці, AI, фізика оновлені.
2. Збір інформації про гравця, оточення, видимі об'єкти (через `player_t`, `AActor`, `FLevelLocals`).
3. Формування структури для LLM (наприклад, JSON, protobuf, інше).
4. Передача у зовнішню LLM (через IPC, REST, WebSocket, інше).
5. Отримання відповіді та вплив на ігровий процес (зміна стану, генерація подій, підказки, тощо).

### 3.3. Діаграма (Mermaid)
```mermaid
flowchart TD
    Start[main/D_DoomMain] --> Init[D_InitGame]
    Init --> Loop[D_DoomLoop]
    Loop --> Ticker[G_Ticker (логіка)]
    Ticker --> Collect[Збір даних для LLM]
    Collect --> LLM[Запит до LLM]
    LLM --> Responder[G_Responder (input)]
    Responder --> Display[D_Display (рендер)]
    Display --> Loop
```

## 1.1. Побудова ігрового всесвіту
- Ігровий всесвіт у GZDoom будується на основі ресурсів (WAD/PK3), які містять карти, об'єкти, текстури, скрипти та інші дані. 
- Під час ініціалізації рівня (через `D_InitGame` та завантаження карти) рушій парсить карту, створює BSP-дерево для просторового поділу, розміщує акторів (`AActor`) у світі, ініціалізує тригери, таймери, властивості секторів.
- Всі об'єкти (гравці, монстри, предмети) представлені як екземпляри класу `AActor`, які додаються у спеціальні списки/ітератори рівня (`FLevelLocals`).
- Взаємодія між об'єктами реалізується через події, колізії, скрипти та AI.

## 1.2. Як визначається, що бачить гравець
- Гравець у GZDoom представлений структурою `player_t`, яка містить посилання на об'єкт-актор (`AActor`), що є "камерою" гравця (`player_t::camera`).
- Положення гравця (`camera->Pos()`), напрямок погляду (`camera->Angles`), поле зору та інші параметри визначають, що саме потрапляє у кадр.
- Для визначення видимих об'єктів використовується BSP-дерево карти: рендерер проходить по секторах, визначає, які області та актори потрапляють у поле зору гравця.
- Всі актори, які знаходяться у видимих секторах та не заблоковані стінами/перешкодами, вважаються "видимими" для гравця.

## 1.3. Звідки брати інформацію про те, що бачить гравець
- Основне джерело — структура `player_t` (файл `src/playsim/d_player.h`), зокрема поле `camera` (типу `AActor`).
- Для отримання позиції та кута огляду: `players[consoleplayer].camera->Pos()`, `players[consoleplayer].camera->Angles`.
- Для отримання списку видимих акторів:
  - Можна використати BSP-дерево та функції рендерера, які вже визначають видимі об'єкти для побудови кадру.
  - Альтернативно — перебрати всіх акторів на рівні (`FLevelLocals::GetThinkerIterator<AActor>()`) і перевірити, чи знаходяться вони у полі зору гравця (геометрично або через функції рендерера).
- Для інтеграції з LLM рекомендується брати дані після оновлення стану світу (`G_Ticker`), але до рендеру (`D_Display`), коли всі позиції та кути актуальні.

## 1.4. Як визначити, хто бачить гравця
- Для кожного актора (наприклад, монстра) можна перевірити, чи знаходиться гравець у його полі зору:
  - Кожен актор має позицію (`AActor::Pos()`), напрямок погляду (`AActor::Angles`), поле зору (може бути задане у властивостях).
  - Для перевірки видимості гравця актором використовується трасування променя (raycast) між актором і гравцем з урахуванням перешкод.
  - AI монстрів часто використовує такі перевірки для прийняття рішень (наприклад, атакувати чи ні).
- Для збору цієї інформації можна перебрати всіх акторів на рівні та для кожного виконати перевірку видимості гравця.

## 1.5. Де і як інтегрувати збір цієї інформації для LLM
- Найкраще місце — після `G_Ticker`, коли всі позиції та стани оновлені, але до рендеру.
- Можна сформувати структуру (наприклад, JSON), яка містить:
  - Позицію та кут огляду гравця
  - Список видимих акторів (з їхніми властивостями)
  - Список акторів, які бачать гравця
  - Додаткові параметри (здоров'я, інвентар, події)
- Цю структуру можна передати у LLM для аналізу, генерації підказок, поведінки AI тощо.

## 3. Опис того, що бачить гравець (для потенційної інтеграції)

### 3.1. Джерела даних
- **player_t::camera** — головна “точка зору” гравця (AActor).
- **AActor** — містить позицію (`Pos()`), напрямок (`Angles`), сектор, стан.
- **FLevelLocals** — дозволяє ітерувати по всіх акторах на рівні.

### 3.2. Алгоритм формування “картини світу” для гравця
1. **Позиція та напрямок гравця**
   - Взяти з `players[consoleplayer].camera->Pos()` і `players[consoleplayer].camera->Angles`.
2. **Видимі актори**
   - Використати BSP-дерево та функції рендерера для визначення, які актори потрапляють у поле зору гравця.
   - Альтернатива: перебрати всіх акторів через `FLevelLocals::GetThinkerIterator<AActor>()` і для кожного перевірити:
     - Чи знаходиться у полі зору (кут, дистанція, прямий “raycast” без перешкод).
     - Чи не заблокований стінами/перешкодами.
3. **Деталізація для кожного видимого актора**
   - Тип (монстр, предмет, декор, інший гравець).
   - Позиція, стан (здоров’я, активність), напрямок.
   - Дистанція до гравця.
   - Додаткові властивості (наприклад, чи взаємодіє з гравцем).
4. **Додаткові параметри**
   - Сектор, в якому знаходиться гравець.
   - Освітлення, ефекти, тригери у полі зору.
   - Стан гравця (здоров’я, інвентар, активна зброя).

### 3.3. Формат представлення
- Рекомендується формувати структуру (наприклад, JSON), де:
  - `player`: позиція, кут огляду, стан, сектор
  - `visible_actors`: масив об’єктів з типом, позицією, станом, дистанцією, властивостями
  - `environment`: освітлення, тригери, особливості сектору

#### Приклад структури (JSON):

```json
{
  "player": {
    "pos": [x, y, z],
    "angle": [pitch, yaw, roll],
    "health": 100,
    "inventory": [...],
    "sector": 5
  },
  "visible_actors": [
    {
      "type": "monster",
      "pos": [x, y, z],
      "angle": ...,
      "state": "active",
      "health": 50,
      "distance": 12.3
    }
  ],
  "environment": {
    "lighting": ...,
    "triggers": [...],
    "specials": [...]
  }
}
```

### 3.4. Потенційні точки для збору цієї інформації
- Після оновлення стану світу (`G_Ticker`), але до рендеру (`D_Display`).
- Можна реалізувати як окрему функцію/модуль, що формує “знімок світу” для зовнішніх систем.

### 3.5. Рекомендації для оптимізації опису "що бачить гравець" для LLM

- **Текстовий опис замість сирих даних**:
  - Формуйте короткий, осмислений текстовий опис ситуації для LLM, наприклад:
    - "Гравець стоїть у темному коридорі, попереду два монстри, зліва двері, справа аптечка."
    - "Перед гравцем ворог на відстані 10 метрів, позаду порожньо, поруч патрони."
  - Для цього використовуйте шаблони, які агрегують дані про найближчі/найважливіші об'єкти, їх типи, відстань, напрямок.

- **Агрегація та фільтрація**:
  - Не передавайте повний список усіх видимих акторів — залишайте тільки найближчих, найважливіших (вороги, предмети, двері, цілі).
  - Групуйте подібні об'єкти: "Попереду три монстри, зліва дві аптечки".
  - Ігноруйте дрібні/неважливі об'єкти (декор, далекі предмети).

- **Частота запитів**:
  - Не надсилайте опис кожного кадру. Оптимально — раз на 0.5–2 секунди, або лише при значних змінах (зміна кімнати, поява ворога, отримання ушкоджень).
  - Можна використовувати "тригерні" події: новий ворог у полі зору, гравець отримав шкоду, знайдено ключовий предмет.

- **Локальна LLM**:
  - Для локальних моделей ще більше спрощуйте опис: короткі речення, мінімум деталей, тільки найважливіше.
  - Можна використовувати коди/теги замість повних описів (наприклад, "ENEMY_LEFT", "ITEM_AHEAD").

- **Приклад оптимізованого текстового опису**:
  - "Гравець у кімнаті. Перед ним два вороги, справа патрони, зліва двері."
  - "Ворог атакує зліва, гравець має 30% здоров'я."

- **Потенційна структура для LLM**:
  - `situation_text`: короткий опис ситуації
  - `important_objects`: масив ключових об'єктів (тип, напрямок, відстань)
  - `player_state`: здоров'я, активна зброя, статус

---

**Висновок:**
- Для інтеграції з LLM у Doom-подібних іграх важливо не перевантажувати модель деталями, а формувати короткі, осмислені текстові описи ситуації, агрегуючи дані про найближчі та найважливіші об'єкти, і зменшувати частоту запитів до LLM.
## 4. Формальні властивості архітектури

- **Модульність**: кожна підсистема ізольована, має чіткі інтерфейси, що дозволяє незалежно розвивати, тестувати та замінювати компоненти.
- **Розширюваність**: підтримка зовнішніх бібліотек, інтеграція LLM через визначені точки, можливість додавання нових підсистем без зміни ядра.
- **Портованість**: підтримка різних ОС через абстракції main/платформозалежних модулів, використання кросплатформених бібліотек.
- **Відтворюваність**: чіткий життєвий цикл, детермінований порядок оновлення стану та рендеру, що забезпечує однакову поведінку на різних платформах.
- **Безпека та стабільність**: обробка винятків, логування, контроль ресурсів, захист від некоректних даних.

---

Цей документ призначений для розробників, які інтегрують LLM або інші зовнішні сервіси у GZDoom, а також для тих, хто вивчає архітектуру рушія для розширення чи модифікації.

*У цьому документі не описано жодної реалізованої інтеграції з LLM/MCP. Всі точки розширення — лише потенційні.*

### 3.6. Автономний режим: LLM як ігровий агент

- **LLM отримує агрегований опис ситуації автоматично, без сигналів від людини.**
- Опис формується кожен N кадрів або при значних змінах у полі зору (наприклад, з'явився ворог, змінився сектор, знайдено предмет).
- LLM самостійно аналізує ситуацію та повертає дію (рух, атака, взаємодія з об'єктом, вибір зброї тощо).
- Весь ігровий цикл (збір даних → формування опису → запит до LLM → виконання дії) відбувається без участі людини.
- Для ефективності:
  - Опис ситуації має бути максимально стислим, але інформативним (див. попередній підпункт).
  - Дії LLM можуть бути у вигляді команд: "move_forward", "turn_left", "shoot", "pickup_health", "open_door" тощо.
  - Важливо забезпечити зворотний зв'язок: результат дії (чи вдалося виконати, чи змінилася ситуація) також передається LLM у наступному описі.

**Висновок:**
- У повністю автономному режимі LLM отримує опис ігрової ситуації, приймає рішення та керує гравцем без жодних сигналів від людини. Вся взаємодія — через агреговані текстові описи та команди.

### 3.7. Аналіз повної ігрової сцени (картинки) для LLM

**Варіанти отримання зображення:**
- Скриншот рендереного кадру (framebuffer capture) — збереження поточного зображення з екрану у форматі PNG/JPEG/RAW.
- Генерація карти (top-down map) — побудова схематичного зображення рівня з розміщенням акторів, предметів, секторів.
- Експорт raw-даних (глибина, маски, сегментація) — додаткові канали для аналізу (depth map, segmentation mask).

**Технічні аспекти:**
- Отримання скриншоту: через API рушія (OpenGL/Vulkan), збереження у тимчасовий файл або буфер пам’яті.
- Формат: PNG/JPEG для компресії, RAW для максимальної якості (але великий розмір).
- Частота: не частіше ніж 1-2 рази на секунду (через об’єм даних і latency).
- Розмір: бажано зменшувати роздільну здатність (наприклад, 320x200, 640x400) для швидшої обробки.
- Передача: через IPC, REST, WebSocket, або прямий доступ до буфера.

**Переваги:**
- Повний візуальний контекст — LLM (або мультимодальна модель) бачить усе, що бачить гравець, без втрати деталей.
- Не залежить від структури ігрових даних, підходить для будь-яких модифікацій/карт.
- Можливість аналізу складних ситуацій, які важко описати текстом (освітлення, ефекти, розташування об’єктів).

**Недоліки:**
- Великий об’єм даних, висока затримка (особливо при передачі через мережу).
- Потреба у мультимодальних LLM (які вміють аналізувати зображення), що значно обмежує вибір моделей.
- Складність інтерпретації: модель може не розпізнати дрібні об’єкти, специфічні елементи інтерфейсу, особливості Doom-стилю графіки.
- Важко отримати структуровану відповідь (наприклад, точні координати об’єктів) лише з картинки.

**Рекомендації:**
- Використовувати аналіз картинки лише як доповнення до текстового/структурованого опису, або для задач, де важливий саме візуальний контекст (наприклад, тестування мультимодальних агентів).
- Зменшувати роздільну здатність і частоту кадрів для оптимізації.
- По можливості додавати допоміжні канали (маски, карти глибини), якщо модель це підтримує.
- Не покладатися лише на аналіз картинки для критичних ігрових рішень — комбінувати з даними про стан світу.
- Враховувати, що мультимодальні LLM мають обмеження на розмір і формат зображень, latency, і можуть не розпізнавати специфічні елементи Doom-інтерфейсу.

**Застереження:**
- Передача зображень у зовнішні сервіси може створювати ризики для приватності/безпеки.
- Не всі LLM підтримують аналіз зображень; для більшості задач достатньо текстового опису.
